// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: suggestions.sql

package dbgen

import (
	"context"
	"time"
)

const approveSuggestion = `-- name: ApproveSuggestion :exec
UPDATE quote_suggestions
SET status = 'approved', reviewed_by = ?, reviewed_at = ?
WHERE id = ?
`

type ApproveSuggestionParams struct {
	ReviewedBy *string    `json:"reviewed_by"`
	ReviewedAt *time.Time `json:"reviewed_at"`
	ID         int64      `json:"id"`
}

func (q *Queries) ApproveSuggestion(ctx context.Context, arg ApproveSuggestionParams) error {
	_, err := q.db.ExecContext(ctx, approveSuggestion, arg.ReviewedBy, arg.ReviewedAt, arg.ID)
	return err
}

const countPendingSuggestions = `-- name: CountPendingSuggestions :one
SELECT COUNT(*) as count FROM quote_suggestions WHERE status = 'pending'
`

func (q *Queries) CountPendingSuggestions(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingSuggestions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingSuggestionsByChannel = `-- name: CountPendingSuggestionsByChannel :one
SELECT COUNT(*) as count FROM quote_suggestions WHERE channel = ? AND status = 'pending'
`

func (q *Queries) CountPendingSuggestionsByChannel(ctx context.Context, channel string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingSuggestionsByChannel, channel)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentSuggestionsByChannel = `-- name: CountRecentSuggestionsByChannel :one
SELECT COUNT(*) as count FROM quote_suggestions
WHERE channel = ? AND submitted_at > ?
`

type CountRecentSuggestionsByChannelParams struct {
	Channel     string    `json:"channel"`
	SubmittedAt time.Time `json:"submitted_at"`
}

func (q *Queries) CountRecentSuggestionsByChannel(ctx context.Context, arg CountRecentSuggestionsByChannelParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecentSuggestionsByChannel, arg.Channel, arg.SubmittedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentSuggestionsByIP = `-- name: CountRecentSuggestionsByIP :one
SELECT COUNT(*) as count FROM quote_suggestions
WHERE submitted_by_ip = ? AND submitted_at > ?
`

type CountRecentSuggestionsByIPParams struct {
	SubmittedByIp string    `json:"submitted_by_ip"`
	SubmittedAt   time.Time `json:"submitted_at"`
}

func (q *Queries) CountRecentSuggestionsByIP(ctx context.Context, arg CountRecentSuggestionsByIPParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countRecentSuggestionsByIP, arg.SubmittedByIp, arg.SubmittedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSuggestion = `-- name: CreateSuggestion :exec
INSERT INTO quote_suggestions (text, author, civilization, opponent_civ, channel, submitted_by_ip, submitted_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateSuggestionParams struct {
	Text          string    `json:"text"`
	Author        *string   `json:"author"`
	Civilization  *string   `json:"civilization"`
	OpponentCiv   *string   `json:"opponent_civ"`
	Channel       string    `json:"channel"`
	SubmittedByIp string    `json:"submitted_by_ip"`
	SubmittedAt   time.Time `json:"submitted_at"`
}

func (q *Queries) CreateSuggestion(ctx context.Context, arg CreateSuggestionParams) error {
	_, err := q.db.ExecContext(ctx, createSuggestion,
		arg.Text,
		arg.Author,
		arg.Civilization,
		arg.OpponentCiv,
		arg.Channel,
		arg.SubmittedByIp,
		arg.SubmittedAt,
	)
	return err
}

const deleteSuggestion = `-- name: DeleteSuggestion :exec
DELETE FROM quote_suggestions WHERE id = ?
`

func (q *Queries) DeleteSuggestion(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSuggestion, id)
	return err
}

const getSuggestionByID = `-- name: GetSuggestionByID :one
SELECT id, text, author, civilization, opponent_civ, channel, submitted_by_ip, submitted_at, status, reviewed_by, reviewed_at FROM quote_suggestions WHERE id = ?
`

func (q *Queries) GetSuggestionByID(ctx context.Context, id int64) (QuoteSuggestion, error) {
	row := q.db.QueryRowContext(ctx, getSuggestionByID, id)
	var i QuoteSuggestion
	err := row.Scan(
		&i.ID,
		&i.Text,
		&i.Author,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.SubmittedByIp,
		&i.SubmittedAt,
		&i.Status,
		&i.ReviewedBy,
		&i.ReviewedAt,
	)
	return i, err
}

const listPendingSuggestions = `-- name: ListPendingSuggestions :many
SELECT id, text, author, civilization, opponent_civ, channel, submitted_by_ip, submitted_at, status, reviewed_by, reviewed_at FROM quote_suggestions
WHERE status = 'pending'
ORDER BY submitted_at DESC
`

func (q *Queries) ListPendingSuggestions(ctx context.Context) ([]QuoteSuggestion, error) {
	rows, err := q.db.QueryContext(ctx, listPendingSuggestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuoteSuggestion{}
	for rows.Next() {
		var i QuoteSuggestion
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.Author,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.SubmittedByIp,
			&i.SubmittedAt,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingSuggestionsByChannel = `-- name: ListPendingSuggestionsByChannel :many
SELECT id, text, author, civilization, opponent_civ, channel, submitted_by_ip, submitted_at, status, reviewed_by, reviewed_at FROM quote_suggestions
WHERE channel = ? AND status = 'pending'
ORDER BY submitted_at DESC
`

func (q *Queries) ListPendingSuggestionsByChannel(ctx context.Context, channel string) ([]QuoteSuggestion, error) {
	rows, err := q.db.QueryContext(ctx, listPendingSuggestionsByChannel, channel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuoteSuggestion{}
	for rows.Next() {
		var i QuoteSuggestion
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.Author,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.SubmittedByIp,
			&i.SubmittedAt,
			&i.Status,
			&i.ReviewedBy,
			&i.ReviewedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectSuggestion = `-- name: RejectSuggestion :exec
UPDATE quote_suggestions
SET status = 'rejected', reviewed_by = ?, reviewed_at = ?
WHERE id = ?
`

type RejectSuggestionParams struct {
	ReviewedBy *string    `json:"reviewed_by"`
	ReviewedAt *time.Time `json:"reviewed_at"`
	ID         int64      `json:"id"`
}

func (q *Queries) RejectSuggestion(ctx context.Context, arg RejectSuggestionParams) error {
	_, err := q.db.ExecContext(ctx, rejectSuggestion, arg.ReviewedBy, arg.ReviewedAt, arg.ID)
	return err
}
