// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quotes.sql

package dbgen

import (
	"context"
	"time"
)

const countQuotes = `-- name: CountQuotes :one
SELECT COUNT(*) as count FROM quotes
`

func (q *Queries) CountQuotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuote = `-- name: CreateQuote :exec
INSERT INTO quotes (user_id, text, author, civilization, opponent_civ, created_at)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateQuoteParams struct {
	UserID       string    `json:"user_id"`
	Text         string    `json:"text"`
	Author       *string   `json:"author"`
	Civilization *string   `json:"civilization"`
	OpponentCiv  *string   `json:"opponent_civ"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg CreateQuoteParams) error {
	_, err := q.db.ExecContext(ctx, createQuote,
		arg.UserID,
		arg.Text,
		arg.Author,
		arg.Civilization,
		arg.OpponentCiv,
		arg.CreatedAt,
	)
	return err
}

const deleteQuote = `-- name: DeleteQuote :exec
DELETE FROM quotes WHERE id = ? AND user_id = ?
`

type DeleteQuoteParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteQuote(ctx context.Context, arg DeleteQuoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteQuote, arg.ID, arg.UserID)
	return err
}

const deleteQuoteByID = `-- name: DeleteQuoteByID :exec
DELETE FROM quotes WHERE id = ?
`

func (q *Queries) DeleteQuoteByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteQuoteByID, id)
	return err
}

const getRandomMatchupQuote = `-- name: GetRandomMatchupQuote :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ FROM quotes
WHERE civilization = ? AND opponent_civ = ?
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomMatchupQuoteParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
}

func (q *Queries) GetRandomMatchupQuote(ctx context.Context, arg GetRandomMatchupQuoteParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomMatchupQuote, arg.Civilization, arg.OpponentCiv)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
	)
	return i, err
}

const getRandomQuote = `-- name: GetRandomQuote :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ FROM quotes
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuote(ctx context.Context) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuote)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
	)
	return i, err
}

const getRandomQuoteByCiv = `-- name: GetRandomQuoteByCiv :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ FROM quotes
WHERE civilization = ?
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuoteByCiv(ctx context.Context, civilization *string) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuoteByCiv, civilization)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
	)
	return i, err
}

const listAllQuotes = `-- name: ListAllQuotes :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ FROM quotes ORDER BY created_at DESC
`

func (q *Queries) ListAllQuotes(ctx context.Context) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listAllQuotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCivilizations = `-- name: ListCivilizations :many
SELECT DISTINCT civilization FROM quotes WHERE civilization IS NOT NULL ORDER BY civilization
`

func (q *Queries) ListCivilizations(ctx context.Context) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, listCivilizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var civilization *string
		if err := rows.Scan(&civilization); err != nil {
			return nil, err
		}
		items = append(items, civilization)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchupQuotes = `-- name: ListMatchupQuotes :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ FROM quotes
WHERE civilization = ? AND opponent_civ = ?
ORDER BY created_at DESC
`

type ListMatchupQuotesParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
}

func (q *Queries) ListMatchupQuotes(ctx context.Context, arg ListMatchupQuotesParams) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listMatchupQuotes, arg.Civilization, arg.OpponentCiv)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByUser = `-- name: ListQuotesByUser :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ FROM quotes
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListQuotesByUser(ctx context.Context, userID string) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
