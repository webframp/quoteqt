// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quotes.sql

package dbgen

import (
	"context"
	"strings"
	"time"
)

const bulkDeleteQuotes = `-- name: BulkDeleteQuotes :exec
DELETE FROM quotes WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) BulkDeleteQuotes(ctx context.Context, ids []int64) error {
	query := bulkDeleteQuotes
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const bulkUpdateChannel = `-- name: BulkUpdateChannel :exec
UPDATE quotes SET channel = ? WHERE id IN (/*SLICE:ids*/?)
`

type BulkUpdateChannelParams struct {
	Channel *string `json:"channel"`
	Ids     []int64 `json:"ids"`
}

func (q *Queries) BulkUpdateChannel(ctx context.Context, arg BulkUpdateChannelParams) error {
	query := bulkUpdateChannel
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Channel)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const bulkUpdateCivilization = `-- name: BulkUpdateCivilization :exec
UPDATE quotes SET civilization = ? WHERE id IN (/*SLICE:ids*/?)
`

type BulkUpdateCivilizationParams struct {
	Civilization *string `json:"civilization"`
	Ids          []int64 `json:"ids"`
}

func (q *Queries) BulkUpdateCivilization(ctx context.Context, arg BulkUpdateCivilizationParams) error {
	query := bulkUpdateCivilization
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Civilization)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const countQuotes = `-- name: CountQuotes :one
SELECT COUNT(*) as count FROM quotes
`

func (q *Queries) CountQuotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuotesByChannel = `-- name: CountQuotesByChannel :one
SELECT COUNT(*) as count FROM quotes WHERE channel = ?
`

func (q *Queries) CountQuotesByChannel(ctx context.Context, channel *string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuotesByChannel, channel)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuote = `-- name: CreateQuote :exec
INSERT INTO quotes (user_id, created_by_email, text, author, civilization, opponent_civ, channel, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateQuoteParams struct {
	UserID         string    `json:"user_id"`
	CreatedByEmail *string   `json:"created_by_email"`
	Text           string    `json:"text"`
	Author         *string   `json:"author"`
	Civilization   *string   `json:"civilization"`
	OpponentCiv    *string   `json:"opponent_civ"`
	Channel        *string   `json:"channel"`
	CreatedAt      time.Time `json:"created_at"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg CreateQuoteParams) error {
	_, err := q.db.ExecContext(ctx, createQuote,
		arg.UserID,
		arg.CreatedByEmail,
		arg.Text,
		arg.Author,
		arg.Civilization,
		arg.OpponentCiv,
		arg.Channel,
		arg.CreatedAt,
	)
	return err
}

const deleteQuote = `-- name: DeleteQuote :exec
DELETE FROM quotes WHERE id = ? AND user_id = ?
`

type DeleteQuoteParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteQuote(ctx context.Context, arg DeleteQuoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteQuote, arg.ID, arg.UserID)
	return err
}

const deleteQuoteByID = `-- name: DeleteQuoteByID :exec
DELETE FROM quotes WHERE id = ?
`

func (q *Queries) DeleteQuoteByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteQuoteByID, id)
	return err
}

const deleteQuoteByText = `-- name: DeleteQuoteByText :exec
DELETE FROM quotes WHERE text = ?
`

func (q *Queries) DeleteQuoteByText(ctx context.Context, text string) error {
	_, err := q.db.ExecContext(ctx, deleteQuoteByText, text)
	return err
}

const getLastUpdated = `-- name: GetLastUpdated :one
SELECT created_at FROM quotes ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetLastUpdated(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getLastUpdated)
	var created_at time.Time
	err := row.Scan(&created_at)
	return created_at, err
}

const getQuoteByID = `-- name: GetQuoteByID :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes WHERE id = ?
`

func (q *Queries) GetQuoteByID(ctx context.Context, id int64) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getQuoteByID, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.CreatedByEmail,
	)
	return i, err
}

const getRandomMatchupQuote = `-- name: GetRandomMatchupQuote :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE civilization = ? AND opponent_civ = ? AND (channel IS NULL OR channel = ?)
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomMatchupQuoteParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
	Channel      *string `json:"channel"`
}

func (q *Queries) GetRandomMatchupQuote(ctx context.Context, arg GetRandomMatchupQuoteParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomMatchupQuote, arg.Civilization, arg.OpponentCiv, arg.Channel)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.CreatedByEmail,
	)
	return i, err
}

const getRandomMatchupQuoteGlobal = `-- name: GetRandomMatchupQuoteGlobal :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE civilization = ? AND opponent_civ = ? AND channel IS NULL
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomMatchupQuoteGlobalParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
}

func (q *Queries) GetRandomMatchupQuoteGlobal(ctx context.Context, arg GetRandomMatchupQuoteGlobalParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomMatchupQuoteGlobal, arg.Civilization, arg.OpponentCiv)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.CreatedByEmail,
	)
	return i, err
}

const getRandomQuote = `-- name: GetRandomQuote :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE channel IS NULL OR channel = ?
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuote(ctx context.Context, channel *string) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuote, channel)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.CreatedByEmail,
	)
	return i, err
}

const getRandomQuoteByCiv = `-- name: GetRandomQuoteByCiv :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE civilization = ? AND (channel IS NULL OR channel = ?)
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomQuoteByCivParams struct {
	Civilization *string `json:"civilization"`
	Channel      *string `json:"channel"`
}

func (q *Queries) GetRandomQuoteByCiv(ctx context.Context, arg GetRandomQuoteByCivParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuoteByCiv, arg.Civilization, arg.Channel)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.CreatedByEmail,
	)
	return i, err
}

const getRandomQuoteByCivGlobal = `-- name: GetRandomQuoteByCivGlobal :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE civilization = ? AND channel IS NULL
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuoteByCivGlobal(ctx context.Context, civilization *string) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuoteByCivGlobal, civilization)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.CreatedByEmail,
	)
	return i, err
}

const getRandomQuoteGlobal = `-- name: GetRandomQuoteGlobal :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE channel IS NULL
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuoteGlobal(ctx context.Context) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuoteGlobal)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
		&i.CreatedByEmail,
	)
	return i, err
}

const listAllQuotes = `-- name: ListAllQuotes :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes ORDER BY created_at DESC
`

func (q *Queries) ListAllQuotes(ctx context.Context) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listAllQuotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannels = `-- name: ListChannels :many
SELECT DISTINCT channel FROM quotes WHERE channel IS NOT NULL ORDER BY channel
`

func (q *Queries) ListChannels(ctx context.Context) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, listChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var channel *string
		if err := rows.Scan(&channel); err != nil {
			return nil, err
		}
		items = append(items, channel)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCivilizations = `-- name: ListCivilizations :many
SELECT DISTINCT civilization FROM quotes WHERE civilization IS NOT NULL ORDER BY civilization
`

func (q *Queries) ListCivilizations(ctx context.Context) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, listCivilizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var civilization *string
		if err := rows.Scan(&civilization); err != nil {
			return nil, err
		}
		items = append(items, civilization)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchupQuotes = `-- name: ListMatchupQuotes :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE civilization = ? AND opponent_civ = ?
ORDER BY created_at DESC
`

type ListMatchupQuotesParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
}

func (q *Queries) ListMatchupQuotes(ctx context.Context, arg ListMatchupQuotesParams) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listMatchupQuotes, arg.Civilization, arg.OpponentCiv)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByChannel = `-- name: ListQuotesByChannel :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE channel = ? OR channel IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListQuotesByChannel(ctx context.Context, channel *string) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByChannel, channel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByChannelOnly = `-- name: ListQuotesByChannelOnly :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE channel = ?
ORDER BY created_at DESC
`

func (q *Queries) ListQuotesByChannelOnly(ctx context.Context, channel *string) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByChannelOnly, channel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByChannelPaginated = `-- name: ListQuotesByChannelPaginated :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE channel = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListQuotesByChannelPaginatedParams struct {
	Channel *string `json:"channel"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
}

func (q *Queries) ListQuotesByChannelPaginated(ctx context.Context, arg ListQuotesByChannelPaginatedParams) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByChannelPaginated, arg.Channel, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByUser = `-- name: ListQuotesByUser :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListQuotesByUser(ctx context.Context, userID string) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesPaginated = `-- name: ListQuotesPaginated :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel, created_by_email FROM quotes ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListQuotesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListQuotesPaginated(ctx context.Context, arg ListQuotesPaginatedParams) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
			&i.CreatedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuote = `-- name: UpdateQuote :exec
UPDATE quotes SET text = ?, author = ?, civilization = ?, opponent_civ = ?, channel = ? WHERE id = ?
`

type UpdateQuoteParams struct {
	Text         string  `json:"text"`
	Author       *string `json:"author"`
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
	Channel      *string `json:"channel"`
	ID           int64   `json:"id"`
}

func (q *Queries) UpdateQuote(ctx context.Context, arg UpdateQuoteParams) error {
	_, err := q.db.ExecContext(ctx, updateQuote,
		arg.Text,
		arg.Author,
		arg.Civilization,
		arg.OpponentCiv,
		arg.Channel,
		arg.ID,
	)
	return err
}
