// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quotes.sql

package dbgen

import (
	"context"
	"time"
)

const countQuotes = `-- name: CountQuotes :one
SELECT COUNT(*) as count FROM quotes
`

func (q *Queries) CountQuotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countQuotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuote = `-- name: CreateQuote :exec
INSERT INTO quotes (user_id, text, author, civilization, opponent_civ, channel, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateQuoteParams struct {
	UserID       string    `json:"user_id"`
	Text         string    `json:"text"`
	Author       *string   `json:"author"`
	Civilization *string   `json:"civilization"`
	OpponentCiv  *string   `json:"opponent_civ"`
	Channel      *string   `json:"channel"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg CreateQuoteParams) error {
	_, err := q.db.ExecContext(ctx, createQuote,
		arg.UserID,
		arg.Text,
		arg.Author,
		arg.Civilization,
		arg.OpponentCiv,
		arg.Channel,
		arg.CreatedAt,
	)
	return err
}

const deleteQuote = `-- name: DeleteQuote :exec
DELETE FROM quotes WHERE id = ? AND user_id = ?
`

type DeleteQuoteParams struct {
	ID     int64  `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteQuote(ctx context.Context, arg DeleteQuoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteQuote, arg.ID, arg.UserID)
	return err
}

const deleteQuoteByID = `-- name: DeleteQuoteByID :exec
DELETE FROM quotes WHERE id = ?
`

func (q *Queries) DeleteQuoteByID(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteQuoteByID, id)
	return err
}

const deleteQuoteByText = `-- name: DeleteQuoteByText :exec
DELETE FROM quotes WHERE text = ?
`

func (q *Queries) DeleteQuoteByText(ctx context.Context, text string) error {
	_, err := q.db.ExecContext(ctx, deleteQuoteByText, text)
	return err
}

const getQuoteByID = `-- name: GetQuoteByID :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes WHERE id = ?
`

func (q *Queries) GetQuoteByID(ctx context.Context, id int64) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getQuoteByID, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
	)
	return i, err
}

const getRandomMatchupQuote = `-- name: GetRandomMatchupQuote :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE civilization = ? AND opponent_civ = ? AND (channel IS NULL OR channel = ?)
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomMatchupQuoteParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
	Channel      *string `json:"channel"`
}

func (q *Queries) GetRandomMatchupQuote(ctx context.Context, arg GetRandomMatchupQuoteParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomMatchupQuote, arg.Civilization, arg.OpponentCiv, arg.Channel)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
	)
	return i, err
}

const getRandomMatchupQuoteGlobal = `-- name: GetRandomMatchupQuoteGlobal :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE civilization = ? AND opponent_civ = ? AND channel IS NULL
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomMatchupQuoteGlobalParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
}

func (q *Queries) GetRandomMatchupQuoteGlobal(ctx context.Context, arg GetRandomMatchupQuoteGlobalParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomMatchupQuoteGlobal, arg.Civilization, arg.OpponentCiv)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
	)
	return i, err
}

const getRandomQuote = `-- name: GetRandomQuote :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE channel IS NULL OR channel = ?
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuote(ctx context.Context, channel *string) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuote, channel)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
	)
	return i, err
}

const getRandomQuoteByCiv = `-- name: GetRandomQuoteByCiv :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE civilization = ? AND (channel IS NULL OR channel = ?)
ORDER BY RANDOM()
LIMIT 1
`

type GetRandomQuoteByCivParams struct {
	Civilization *string `json:"civilization"`
	Channel      *string `json:"channel"`
}

func (q *Queries) GetRandomQuoteByCiv(ctx context.Context, arg GetRandomQuoteByCivParams) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuoteByCiv, arg.Civilization, arg.Channel)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
	)
	return i, err
}

const getRandomQuoteByCivGlobal = `-- name: GetRandomQuoteByCivGlobal :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE civilization = ? AND channel IS NULL
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuoteByCivGlobal(ctx context.Context, civilization *string) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuoteByCivGlobal, civilization)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
	)
	return i, err
}

const getRandomQuoteGlobal = `-- name: GetRandomQuoteGlobal :one
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE channel IS NULL
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomQuoteGlobal(ctx context.Context) (Quote, error) {
	row := q.db.QueryRowContext(ctx, getRandomQuoteGlobal)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Text,
		&i.Author,
		&i.CreatedAt,
		&i.Civilization,
		&i.OpponentCiv,
		&i.Channel,
	)
	return i, err
}

const listAllQuotes = `-- name: ListAllQuotes :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes ORDER BY created_at DESC
`

func (q *Queries) ListAllQuotes(ctx context.Context) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listAllQuotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannels = `-- name: ListChannels :many
SELECT DISTINCT channel FROM quotes WHERE channel IS NOT NULL ORDER BY channel
`

func (q *Queries) ListChannels(ctx context.Context) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, listChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var channel *string
		if err := rows.Scan(&channel); err != nil {
			return nil, err
		}
		items = append(items, channel)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCivilizations = `-- name: ListCivilizations :many
SELECT DISTINCT civilization FROM quotes WHERE civilization IS NOT NULL ORDER BY civilization
`

func (q *Queries) ListCivilizations(ctx context.Context) ([]*string, error) {
	rows, err := q.db.QueryContext(ctx, listCivilizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var civilization *string
		if err := rows.Scan(&civilization); err != nil {
			return nil, err
		}
		items = append(items, civilization)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchupQuotes = `-- name: ListMatchupQuotes :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE civilization = ? AND opponent_civ = ?
ORDER BY created_at DESC
`

type ListMatchupQuotesParams struct {
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
}

func (q *Queries) ListMatchupQuotes(ctx context.Context, arg ListMatchupQuotesParams) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listMatchupQuotes, arg.Civilization, arg.OpponentCiv)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByChannel = `-- name: ListQuotesByChannel :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE channel = ? OR channel IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListQuotesByChannel(ctx context.Context, channel *string) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByChannel, channel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesByUser = `-- name: ListQuotesByUser :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListQuotesByUser(ctx context.Context, userID string) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotesPaginated = `-- name: ListQuotesPaginated :many
SELECT id, user_id, text, author, created_at, civilization, opponent_civ, channel FROM quotes ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListQuotesPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListQuotesPaginated(ctx context.Context, arg ListQuotesPaginatedParams) ([]Quote, error) {
	rows, err := q.db.QueryContext(ctx, listQuotesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Text,
			&i.Author,
			&i.CreatedAt,
			&i.Civilization,
			&i.OpponentCiv,
			&i.Channel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuote = `-- name: UpdateQuote :exec
UPDATE quotes SET text = ?, author = ?, civilization = ?, opponent_civ = ?, channel = ? WHERE id = ?
`

type UpdateQuoteParams struct {
	Text         string  `json:"text"`
	Author       *string `json:"author"`
	Civilization *string `json:"civilization"`
	OpponentCiv  *string `json:"opponent_civ"`
	Channel      *string `json:"channel"`
	ID           int64   `json:"id"`
}

func (q *Queries) UpdateQuote(ctx context.Context, arg UpdateQuoteParams) error {
	_, err := q.db.ExecContext(ctx, updateQuote,
		arg.Text,
		arg.Author,
		arg.Civilization,
		arg.OpponentCiv,
		arg.Channel,
		arg.ID,
	)
	return err
}
