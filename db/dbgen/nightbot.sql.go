// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: nightbot.sql

package dbgen

import (
	"context"
	"time"
)

const createNightbotSnapshot = `-- name: CreateNightbotSnapshot :one
INSERT INTO nightbot_snapshots (channel_name, command_count, commands_json, created_by, note)
VALUES (?, ?, ?, ?, ?)
RETURNING id
`

type CreateNightbotSnapshotParams struct {
	ChannelName  string  `json:"channel_name"`
	CommandCount int64   `json:"command_count"`
	CommandsJson string  `json:"commands_json"`
	CreatedBy    string  `json:"created_by"`
	Note         *string `json:"note"`
}

func (q *Queries) CreateNightbotSnapshot(ctx context.Context, arg CreateNightbotSnapshotParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNightbotSnapshot,
		arg.ChannelName,
		arg.CommandCount,
		arg.CommandsJson,
		arg.CreatedBy,
		arg.Note,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteAllNightbotTokens = `-- name: DeleteAllNightbotTokens :exec
DELETE FROM nightbot_tokens WHERE user_email = ?
`

func (q *Queries) DeleteAllNightbotTokens(ctx context.Context, userEmail string) error {
	_, err := q.db.ExecContext(ctx, deleteAllNightbotTokens, userEmail)
	return err
}

const deleteNightbotSnapshot = `-- name: DeleteNightbotSnapshot :exec
DELETE FROM nightbot_snapshots WHERE id = ?
`

func (q *Queries) DeleteNightbotSnapshot(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteNightbotSnapshot, id)
	return err
}

const deleteNightbotToken = `-- name: DeleteNightbotToken :exec
DELETE FROM nightbot_tokens WHERE user_email = ? AND channel_name = ?
`

type DeleteNightbotTokenParams struct {
	UserEmail   string `json:"user_email"`
	ChannelName string `json:"channel_name"`
}

func (q *Queries) DeleteNightbotToken(ctx context.Context, arg DeleteNightbotTokenParams) error {
	_, err := q.db.ExecContext(ctx, deleteNightbotToken, arg.UserEmail, arg.ChannelName)
	return err
}

const getAllChannelsLastSnapshot = `-- name: GetAllChannelsLastSnapshot :many
SELECT channel_name, 
       (SELECT snapshot_at FROM nightbot_snapshots s2 
        WHERE s2.channel_name = s1.channel_name AND s2.deleted_at IS NULL 
        ORDER BY snapshot_at DESC LIMIT 1) as last_snapshot_at
FROM nightbot_snapshots s1 
WHERE deleted_at IS NULL
GROUP BY channel_name
`

type GetAllChannelsLastSnapshotRow struct {
	ChannelName    string    `json:"channel_name"`
	LastSnapshotAt time.Time `json:"last_snapshot_at"`
}

// Returns the most recent snapshot date for all channels
func (q *Queries) GetAllChannelsLastSnapshot(ctx context.Context) ([]GetAllChannelsLastSnapshotRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllChannelsLastSnapshot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllChannelsLastSnapshotRow{}
	for rows.Next() {
		var i GetAllChannelsLastSnapshotRow
		if err := rows.Scan(&i.ChannelName, &i.LastSnapshotAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDeletedSnapshots = `-- name: GetAllDeletedSnapshots :many
SELECT id, channel_name, snapshot_at, command_count, commands_json, created_by, note, last_diff_added, last_diff_removed, last_diff_modified, last_diff_at, deleted_at, deleted_by FROM nightbot_snapshots WHERE deleted_at IS NOT NULL ORDER BY deleted_at DESC LIMIT ?
`

func (q *Queries) GetAllDeletedSnapshots(ctx context.Context, limit int64) ([]NightbotSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getAllDeletedSnapshots, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NightbotSnapshot{}
	for rows.Next() {
		var i NightbotSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.ChannelName,
			&i.SnapshotAt,
			&i.CommandCount,
			&i.CommandsJson,
			&i.CreatedBy,
			&i.Note,
			&i.LastDiffAdded,
			&i.LastDiffRemoved,
			&i.LastDiffModified,
			&i.LastDiffAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelLastSnapshot = `-- name: GetChannelLastSnapshot :one
SELECT snapshot_at FROM nightbot_snapshots 
WHERE channel_name = ? AND deleted_at IS NULL 
ORDER BY snapshot_at DESC LIMIT 1
`

// Returns the most recent snapshot date for a channel
func (q *Queries) GetChannelLastSnapshot(ctx context.Context, channelName string) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getChannelLastSnapshot, channelName)
	var snapshot_at time.Time
	err := row.Scan(&snapshot_at)
	return snapshot_at, err
}

const getDeletedNightbotSnapshots = `-- name: GetDeletedNightbotSnapshots :many
SELECT id, channel_name, snapshot_at, command_count, commands_json, created_by, note, last_diff_added, last_diff_removed, last_diff_modified, last_diff_at, deleted_at, deleted_by FROM nightbot_snapshots WHERE channel_name = ? AND deleted_at IS NOT NULL ORDER BY deleted_at DESC LIMIT ?
`

type GetDeletedNightbotSnapshotsParams struct {
	ChannelName string `json:"channel_name"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) GetDeletedNightbotSnapshots(ctx context.Context, arg GetDeletedNightbotSnapshotsParams) ([]NightbotSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getDeletedNightbotSnapshots, arg.ChannelName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NightbotSnapshot{}
	for rows.Next() {
		var i NightbotSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.ChannelName,
			&i.SnapshotAt,
			&i.CommandCount,
			&i.CommandsJson,
			&i.CreatedBy,
			&i.Note,
			&i.LastDiffAdded,
			&i.LastDiffRemoved,
			&i.LastDiffModified,
			&i.LastDiffAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImportedOnlyChannels = `-- name: GetImportedOnlyChannels :many
SELECT DISTINCT channel_name FROM nightbot_snapshots
WHERE channel_name NOT IN (SELECT channel_name FROM nightbot_tokens)
  AND deleted_at IS NULL
ORDER BY channel_name
`

// Returns channels that have snapshots but no OAuth tokens (imported via Tampermonkey)
func (q *Queries) GetImportedOnlyChannels(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getImportedOnlyChannels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var channel_name string
		if err := rows.Scan(&channel_name); err != nil {
			return nil, err
		}
		items = append(items, channel_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNightbotSnapshot = `-- name: GetNightbotSnapshot :one
SELECT id, channel_name, snapshot_at, command_count, commands_json, created_by, note, last_diff_added, last_diff_removed, last_diff_modified, last_diff_at, deleted_at, deleted_by FROM nightbot_snapshots WHERE id = ?
`

func (q *Queries) GetNightbotSnapshot(ctx context.Context, id int64) (NightbotSnapshot, error) {
	row := q.db.QueryRowContext(ctx, getNightbotSnapshot, id)
	var i NightbotSnapshot
	err := row.Scan(
		&i.ID,
		&i.ChannelName,
		&i.SnapshotAt,
		&i.CommandCount,
		&i.CommandsJson,
		&i.CreatedBy,
		&i.Note,
		&i.LastDiffAdded,
		&i.LastDiffRemoved,
		&i.LastDiffModified,
		&i.LastDiffAt,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const getNightbotSnapshots = `-- name: GetNightbotSnapshots :many
SELECT id, channel_name, snapshot_at, command_count, commands_json, created_by, note, last_diff_added, last_diff_removed, last_diff_modified, last_diff_at, deleted_at, deleted_by FROM nightbot_snapshots WHERE channel_name = ? AND deleted_at IS NULL ORDER BY snapshot_at DESC LIMIT ?
`

type GetNightbotSnapshotsParams struct {
	ChannelName string `json:"channel_name"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) GetNightbotSnapshots(ctx context.Context, arg GetNightbotSnapshotsParams) ([]NightbotSnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getNightbotSnapshots, arg.ChannelName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NightbotSnapshot{}
	for rows.Next() {
		var i NightbotSnapshot
		if err := rows.Scan(
			&i.ID,
			&i.ChannelName,
			&i.SnapshotAt,
			&i.CommandCount,
			&i.CommandsJson,
			&i.CreatedBy,
			&i.Note,
			&i.LastDiffAdded,
			&i.LastDiffRemoved,
			&i.LastDiffModified,
			&i.LastDiffAt,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNightbotToken = `-- name: GetNightbotToken :one
SELECT id, user_email, channel_name, channel_display_name, access_token, refresh_token, expires_at, created_at, updated_at FROM nightbot_tokens WHERE user_email = ? AND channel_name = ? LIMIT 1
`

type GetNightbotTokenParams struct {
	UserEmail   string `json:"user_email"`
	ChannelName string `json:"channel_name"`
}

func (q *Queries) GetNightbotToken(ctx context.Context, arg GetNightbotTokenParams) (NightbotToken, error) {
	row := q.db.QueryRowContext(ctx, getNightbotToken, arg.UserEmail, arg.ChannelName)
	var i NightbotToken
	err := row.Scan(
		&i.ID,
		&i.UserEmail,
		&i.ChannelName,
		&i.ChannelDisplayName,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNightbotTokensByUser = `-- name: GetNightbotTokensByUser :many
SELECT id, user_email, channel_name, channel_display_name, access_token, refresh_token, expires_at, created_at, updated_at FROM nightbot_tokens WHERE user_email = ? ORDER BY channel_display_name
`

func (q *Queries) GetNightbotTokensByUser(ctx context.Context, userEmail string) ([]NightbotToken, error) {
	rows, err := q.db.QueryContext(ctx, getNightbotTokensByUser, userEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NightbotToken{}
	for rows.Next() {
		var i NightbotToken
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.ChannelName,
			&i.ChannelDisplayName,
			&i.AccessToken,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const purgeOldDeletedSnapshots = `-- name: PurgeOldDeletedSnapshots :exec
DELETE FROM nightbot_snapshots WHERE deleted_at IS NOT NULL AND deleted_at < datetime('now', '-14 days')
`

// Permanently delete snapshots that were soft-deleted more than 14 days ago
func (q *Queries) PurgeOldDeletedSnapshots(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, purgeOldDeletedSnapshots)
	return err
}

const restoreNightbotSnapshot = `-- name: RestoreNightbotSnapshot :exec
UPDATE nightbot_snapshots SET deleted_at = NULL, deleted_by = NULL WHERE id = ?
`

func (q *Queries) RestoreNightbotSnapshot(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, restoreNightbotSnapshot, id)
	return err
}

const softDeleteNightbotSnapshot = `-- name: SoftDeleteNightbotSnapshot :exec
UPDATE nightbot_snapshots SET deleted_at = CURRENT_TIMESTAMP, deleted_by = ? WHERE id = ?
`

type SoftDeleteNightbotSnapshotParams struct {
	DeletedBy *string `json:"deleted_by"`
	ID        int64   `json:"id"`
}

func (q *Queries) SoftDeleteNightbotSnapshot(ctx context.Context, arg SoftDeleteNightbotSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteNightbotSnapshot, arg.DeletedBy, arg.ID)
	return err
}

const updateSnapshotDiffCache = `-- name: UpdateSnapshotDiffCache :exec
UPDATE nightbot_snapshots
SET last_diff_added = ?, last_diff_removed = ?, last_diff_modified = ?, last_diff_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateSnapshotDiffCacheParams struct {
	LastDiffAdded    *int64 `json:"last_diff_added"`
	LastDiffRemoved  *int64 `json:"last_diff_removed"`
	LastDiffModified *int64 `json:"last_diff_modified"`
	ID               int64  `json:"id"`
}

func (q *Queries) UpdateSnapshotDiffCache(ctx context.Context, arg UpdateSnapshotDiffCacheParams) error {
	_, err := q.db.ExecContext(ctx, updateSnapshotDiffCache,
		arg.LastDiffAdded,
		arg.LastDiffRemoved,
		arg.LastDiffModified,
		arg.ID,
	)
	return err
}

const updateSnapshotNote = `-- name: UpdateSnapshotNote :exec
UPDATE nightbot_snapshots SET note = ? WHERE id = ?
`

type UpdateSnapshotNoteParams struct {
	Note *string `json:"note"`
	ID   int64   `json:"id"`
}

func (q *Queries) UpdateSnapshotNote(ctx context.Context, arg UpdateSnapshotNoteParams) error {
	_, err := q.db.ExecContext(ctx, updateSnapshotNote, arg.Note, arg.ID)
	return err
}

const upsertNightbotToken = `-- name: UpsertNightbotToken :exec
INSERT INTO nightbot_tokens (user_email, channel_name, channel_display_name, access_token, refresh_token, expires_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(user_email, channel_name) DO UPDATE SET
    channel_display_name = excluded.channel_display_name,
    access_token = excluded.access_token,
    refresh_token = excluded.refresh_token,
    expires_at = excluded.expires_at,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertNightbotTokenParams struct {
	UserEmail          string    `json:"user_email"`
	ChannelName        string    `json:"channel_name"`
	ChannelDisplayName *string   `json:"channel_display_name"`
	AccessToken        string    `json:"access_token"`
	RefreshToken       string    `json:"refresh_token"`
	ExpiresAt          time.Time `json:"expires_at"`
}

func (q *Queries) UpsertNightbotToken(ctx context.Context, arg UpsertNightbotTokenParams) error {
	_, err := q.db.ExecContext(ctx, upsertNightbotToken,
		arg.UserEmail,
		arg.ChannelName,
		arg.ChannelDisplayName,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	return err
}
