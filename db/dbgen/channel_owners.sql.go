// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: channel_owners.sql

package dbgen

import (
	"context"
)

const addChannelOwner = `-- name: AddChannelOwner :exec
INSERT INTO channel_owners (channel, user_email, invited_by) VALUES (?, ?, ?)
`

type AddChannelOwnerParams struct {
	Channel   string `json:"channel"`
	UserEmail string `json:"user_email"`
	InvitedBy string `json:"invited_by"`
}

func (q *Queries) AddChannelOwner(ctx context.Context, arg AddChannelOwnerParams) error {
	_, err := q.db.ExecContext(ctx, addChannelOwner, arg.Channel, arg.UserEmail, arg.InvitedBy)
	return err
}

const countChannelOwners = `-- name: CountChannelOwners :one
SELECT COUNT(*) as count FROM channel_owners
`

func (q *Queries) CountChannelOwners(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countChannelOwners)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getChannelsByOwner = `-- name: GetChannelsByOwner :many
SELECT channel FROM channel_owners WHERE user_email = ?
`

func (q *Queries) GetChannelsByOwner(ctx context.Context, userEmail string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getChannelsByOwner, userEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var channel string
		if err := rows.Scan(&channel); err != nil {
			return nil, err
		}
		items = append(items, channel)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnersByChannel = `-- name: GetOwnersByChannel :many
SELECT user_email FROM channel_owners WHERE channel = ?
`

func (q *Queries) GetOwnersByChannel(ctx context.Context, channel string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getOwnersByChannel, channel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var user_email string
		if err := rows.Scan(&user_email); err != nil {
			return nil, err
		}
		items = append(items, user_email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isChannelOwner = `-- name: IsChannelOwner :one
SELECT COUNT(*) > 0 as is_owner FROM channel_owners WHERE channel = ? AND user_email = ?
`

type IsChannelOwnerParams struct {
	Channel   string `json:"channel"`
	UserEmail string `json:"user_email"`
}

func (q *Queries) IsChannelOwner(ctx context.Context, arg IsChannelOwnerParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isChannelOwner, arg.Channel, arg.UserEmail)
	var is_owner bool
	err := row.Scan(&is_owner)
	return is_owner, err
}

const listAllChannelOwners = `-- name: ListAllChannelOwners :many
SELECT id, channel, user_email, invited_at, invited_by FROM channel_owners ORDER BY channel, user_email
`

func (q *Queries) ListAllChannelOwners(ctx context.Context) ([]ChannelOwner, error) {
	rows, err := q.db.QueryContext(ctx, listAllChannelOwners)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChannelOwner{}
	for rows.Next() {
		var i ChannelOwner
		if err := rows.Scan(
			&i.ID,
			&i.Channel,
			&i.UserEmail,
			&i.InvitedAt,
			&i.InvitedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChannelOwner = `-- name: RemoveChannelOwner :exec
DELETE FROM channel_owners WHERE channel = ? AND user_email = ?
`

type RemoveChannelOwnerParams struct {
	Channel   string `json:"channel"`
	UserEmail string `json:"user_email"`
}

func (q *Queries) RemoveChannelOwner(ctx context.Context, arg RemoveChannelOwnerParams) error {
	_, err := q.db.ExecContext(ctx, removeChannelOwner, arg.Channel, arg.UserEmail)
	return err
}
